Reglas específicas para campos JSONB (Archivo 2)

Acceso y referencias a campos JSONB
	•	No asumir claves JSONB como columnas: Nunca trates una clave dentro de un JSONB como si fuera una columna directa de la tabla. Si necesitas acceder a un dato dentro de una columna JSONB, siempre usa la sintaxis del operador JSONB adecuado. Por ejemplo, en lugar de SELECT clave FROM tabla, debes usar SELECT jsonb_col->>'clave' AS clave FROM tabla. Esto aplica en todas las cláusulas SQL (SELECT, WHERE, GROUP BY, ORDER BY): referencia el campo JSONB seguido de -> o ->> según necesites un objeto JSON o un texto.
	•	Verificar existencia en tabla vs JSON: Antes de usar un nombre de campo en una consulta, confirma si pertenece a una columna física de la tabla o si es una clave dentro de una columna JSONB. Por ejemplo, campos como "amount", "certificate_ids", "adjudication_date", etc., podrían estar almacenados dentro de un JSONB. Si no existen como columnas individuales en el esquema, debes obtenerlos mediante la columna JSONB correspondiente (ej. tabla.jsonb_data->>'amount'). No hagas SELECT ni filtros directamente sobre nombres de clave JSONB sin el operador, ya que producirán errores de columna inexistente.
	•	Manejo de valores nulos en JSON: Si un campo JSONB puede ser nulo o cadena vacía, manéjalo apropiadamente antes de usarlo en expresiones. Por ejemplo, al extraer una clave que podría no existir o ser "", considera usar NULLIF(jsonb_col->>'campo', '') para convertir cadenas vacías en NULL, o verifica con una condición jsonb_col->>'campo' IS NOT NULL según el caso, antes de aplicar funciones o casteos.

Conversión de tipos desde JSONB
	•	Números (JSONB a numérico): Muchos valores numéricos dentro de JSONB vienen como texto. Nunca asumas que siempre son enteros puros; pueden incluir decimales o incluso ser cadenas vacías. Por lo tanto:
	•	Si extraes un número de un JSONB, no lo conviertas directamente a INTEGER a menos que estés seguro de que siempre será un entero válido sin formato decimal. En su lugar, suele ser más seguro convertirlo a NUMERIC con (jsonb_col->>'campo')::NUMERIC para abarcar enteros y decimales.
	•	Patrón para números de JSONB: Si el valor puede estar vacío o faltar, utiliza COALESCE y NULLIF para evitar errores de conversión: COALESCE(NULLIF(jsonb_col->>'campo', '')::NUMERIC, 0). Esto convierte la cadena a numérico cuando hay valor y usa 0 (u otro valor por defecto) cuando la clave está ausente o vacía. Aplica este patrón de forma consistente a cualquier conversión de JSONB a tipos numéricos (NUMERIC, INTEGER, FLOAT, etc.) susceptible de valores vacíos.
	•	No intentes castear un valor JSONB directamente a un arreglo de JSONB (jsonb[]) u otros tipos incompatibles – extrae siempre el valor primitivo adecuado antes de cualquier conversión.
	•	Dentro de funciones agregadas: Cuando uses funciones como SUM, AVG, MIN, MAX sobre valores numéricos provenientes de JSONB, realiza el cast dentro de la función agregada, no después. Ejemplo: SUM((jsonb_col->>'monto')::NUMERIC) es correcto, mientras que SUM(jsonb_col->>'monto')::NUMERIC es incorrecto. De esta manera te aseguras de sumar números y no strings, evitando errores. También, si aplicas filtros dentro de un agregado (por ejemplo SUM(...) FILTER), es preferible integrar el manejo de NULL/vacío dentro de la expresión del SUM (usando COALESCE/NULLIF) en lugar de envolver el resultado total.
	•	No duplicar casteos: Si necesitas el mismo valor numérico extraído de JSONB en varias partes de la consulta (en SELECT, ORDER BY, etc.), extrae y convierte ese valor una sola vez (por ejemplo, en un CTE o subconsulta inicial) y reutiliza el alias. Así evitas repetir el cast multiple veces y disminuyes la probabilidad de inconsistencias o errores.
	•	Fechas (JSONB a fecha): Las fechas almacenadas como texto en JSONB (p. ej. formato "DD-MM-YYYY") requieren conversión explícita:
	•	No intentes hacer cast directo (::DATE) sobre una cadena con formato personalizado. En su lugar, utiliza la función TO_DATE(cadena, formato) indicando el patrón correcto. Ejemplo: TO_DATE(jsonb_col->>'created', 'DD-MM-YYYY') convierte el texto "31-12-2025" a una fecha PostgreSQL.
	•	Si vas a comparar una fecha proveniente de JSONB con una fecha real (por ejemplo, CURRENT_DATE u otra columna DATE), asegúrate de convertir primero el valor JSONB a tipo DATE. Es decir, convierte el lado del JSONB con TO_DATE o un cast apropiado en vez de convertir la fecha real a texto. Ambas partes de la comparación deben ser del mismo tipo (DATE con DATE, por ejemplo).
	•	Campos de fecha vacíos: Cuando un campo de fecha en JSONB (o un campo de tipo texto que contiene fecha) pueda venir vacío, sigue este patrón para evitar errores: TO_DATE(NULLIF(jsonb_col->>'fecha', ''), 'DD-MM-YYYY'). Así, si la cadena es '' se convertirá en NULL antes del TO_DATE, previniendo excepciones. Nunca uses este patrón sobre columnas que ya son de tipo DATE/TIMESTAMP (no envuelvas columnas de fecha reales en TO_DATE ni en NULLIF – trátalas directamente).
	•	No uses funciones de formateo de fecha (TO_CHAR, concatenaciones de texto, etc.) para luego comparar resultados de fecha con texto. Es mejor convertir el texto JSONB a fecha y compararlo con la columna fecha, o aplicar funciones de fecha (como DATE_TRUNC, operaciones con intervalos, etc.) directamente sobre los valores de fecha reales.
	•	Booleanos: Las claves booleanas dentro de JSONB se obtienen como texto "true"/"false" al usar ->>. Para evaluarlas correctamente en condiciones:
	•	Convierte la cadena a booleano con un cast y compárala con TRUE/FALSE explícitamente. Por ejemplo: (jsonb_col->>'flag_activo')::BOOLEAN IS TRUE verifica si la clave "flag_activo" es verdaderamente booleana verdadera. Análogamente, podrías usar IS FALSE o comparar con = TRUE/FALSE según convenga.
	•	Aplica esta regla para todos los campos JSONB que representen valores lógicos. No confíes en la comparación directa de la cadena "true" sin cast, ya que no es seguro ni semánticamente claro en SQL.

Agregaciones y cálculos con valores JSONB
	•	Suma y conteo de valores JSONB: Al agregar valores numéricos provenientes de JSONB, combínalos con las conversiones adecuadas dentro de la misma expresión. Por ejemplo, para sumar montos de un JSONB, usa SUM(COALESCE(NULLIF(jsonb_col->>'monto', '')::NUMERIC, 0)). Esto convierte cada valor a numérico (tratando vacío como 0) antes de sumarlos. Evita aplicar COALESCE al resultado total de SUM — en su lugar, maneja los nulos por registro dentro de la función agregada.
	•	Condiciones dentro de agregados: Para conteos o sumas condicionales basadas en contenido JSONB, utiliza CASE WHEN. Ejemplo: si quieres contar cuántos objetos JSON en una columna no están vacíos, puedes hacer SUM(CASE WHEN (jsonb_col->'subobj')::TEXT != '{}' THEN 1 ELSE 0 END). Esto agrega 1 por cada entrada cuyo subobjeto JSON no es vacío. No intentes sumar directamente una expresión booleana como (jsonb_col->'subobj')::TEXT != '{}' ya que PostgreSQL no suma valores lógicos. El patrón CASE... THEN 1 ELSE 0 es el correcto para estos casos.
	•	Porcentajes u operaciones combinadas: Si calculas métricas como porcentajes usando campos JSONB (por ejemplo, porcentaje del total que cumple cierta condición), asegúrate de estructurar la fórmula con los paréntesis correctamente anidados después de convertir los valores JSONB a numérico. Utiliza NULLIF dentro de divisiones para evitar divisiones por cero, y envuelve el resultado en ROUND o COALESCE según sea necesario. Un ejemplo completo sería: COALESCE(ROUND(100.0 * SUM((jsonb_col->>'valor')::NUMERIC) / NULLIF(SUM((jsonb_col->>'total')::NUMERIC), 0), 0), 0).
	•	Optimizar repetición de cálculos: Si necesitas usar repetidamente el mismo cálculo derivado de JSONB (por ejemplo, extraer un valor casteado) en múltiples lugares de la consulta (SELECT, WHERE, ORDER BY), considera hacerlo solo una vez en un subquery o CTE inicial. Dale un alias al resultado y reutilízalo. Esto no solo hace la consulta más legible, sino que evita errores de consistencia y múltiples casteos costosos del mismo campo JSON.

Manejo de arrays y objetos JSONB
	•	Funciones JSONB adecuadas según tipo: Utiliza la función correspondiente al tipo de estructura JSONB:
	•	Si el campo JSONB es un objeto (JSON), recórrelo con jsonb_each o jsonb_each_text, que devuelven pares clave/valor.
	•	Si el campo JSONB es un arreglo (array), utilice jsonb_array_elements para expandir sus elementos.
	•	Nunca uses jsonb_each sobre algo que pueda ser un array ni jsonb_array_elements sobre algo que no sea array. Si no estás seguro del tipo, verifica primero con jsonb_typeof(campo) y/o asegúrate de la estructura de tus datos.
	•	Verificaciones antes de operar: Antes de aplicar funciones como jsonb_array_elements, jsonb_each o jsonb_array_length sobre un campo JSONB, agrega condiciones de seguridad:
	•	Comprueba que el campo no sea nulo y que tenga el tipo esperado. Por ejemplo, para usar jsonb_array_length(jsonb_col->'items'), podrías poner en la cláusula WHERE: jsonb_col->'items' IS NOT NULL AND jsonb_typeof(jsonb_col->'items') = 'array'. Esto previene errores si items no existe, es nulo o no es un array. De igual forma, si vas a iterar con jsonb_each, podrías asegurarte de que jsonb_typeof(jsonb_col->'obj') = 'object' antes de hacerlo.
	•	Para chequear si un objeto JSONB no está vacío, no intentes usar funciones set-returning en el WHERE (como jsonb_object_keys). En su lugar, usa condiciones: jsonb_col IS NOT NULL AND jsonb_typeof(jsonb_col) = 'object' AND jsonb_col::TEXT != '{}'. De esta manera confirmas que el campo no es nulo, es de tipo objeto y su representación textual no es un JSON vacío.
	•	Análogamente, para verificar que un array JSONB no esté vacío: jsonb_typeof(jsonb_col) = 'array' AND jsonb_array_length(jsonb_col) > 0.
	•	Expansión de JSONB en consultas (JOIN/LATERAL):
	•	Cuando utilices jsonb_each o jsonb_array_elements en la cláusula FROM (incluyendo en un JOIN LATERAL), define un alias adecuado. Por ejemplo:
	•	Para objetos: FROM jsonb_each(tabla.jsonb_obj) AS elem(key, value) te dará un alias elem con columnas key y value. Si solo necesitas los valores, puedes hacer AS elem y luego usar elem.value.
	•	Para arrays: FROM jsonb_array_elements(tabla.jsonb_array) AS arr(element) dará un alias arr con una columna element que representa cada elemento del array.
	•	Acceso a subcampos: Después de expandir, recuerda que los subelementos siguen siendo JSON. Para obtener un campo interno, debes usar de nuevo los operadores JSONB sobre el alias. Por ejemplo, si hiciste jsonb_array_elements(tabla.col->'items') AS i(item), para acceder al campo “price” dentro de cada item usarías i.item->>'price'. No intentes usar sintaxis como i.price directamente, ya que price no es una columna real de la tabla alias, sino una clave dentro del JSON.
	•	Evitar SRF en agregados: No coloques llamadas a funciones que retornan sets (SRF) directamente dentro de agregaciones. Es decir, no hagas SELECT json_agg(jsonb_array_elements(columna_jsonb)) ... ni SUM(jsonb_array_elements(...)->>'campo'). PostgreSQL no permite SRF dentro de una función agregada. En su lugar, primero expande el JSONB con un JOIN LATERAL o subconsulta, y luego realiza la agregación sobre el resultado expandido. Por ejemplo, puedes hacer un LATERAL para jsonb_array_elements y luego en una consulta externa hacer SUM(alias.element->>'campo'::NUMERIC).
	•	Agregaciones después de expandir: Si necesitas sumar o contar elementos dentro de un JSONB array por cada fila padre, sigue un patrón de dos pasos: (1) Expande el array con jsonb_array_elements en un CTE o subconsulta lateral, filtrando dentro de esta subconsulta si es necesario; (2) En la consulta padre, aplica SUM() o COUNT() sobre los resultados expandidos. Así evitas errores de contexto y te aseguras de contar/sumar correctamente relacionados a cada fila original.
	•	Filtrado de resultados JSON expandido: Si debes filtrar elementos de un JSONB expandido, hazlo dentro de la subconsulta o LATERAL que recorre el JSON, en lugar de en la cláusula WHERE externa (que podría eliminar toda la fila principal si no hay elementos coincidentes). Por ejemplo, es preferible: LEFT JOIN LATERAL (SELECT ... FROM jsonb_array_elements(tabla.col->'arr') WHERE <condición>) AS alias ON TRUE para filtrar los elementos JSON, en vez de poner la condición en un WHERE del SELECT principal que involucre el alias lateral.
	•	Ejemplos de uso correcto:
Iterar un array JSONB:
LEFT JOIN LATERAL jsonb_array_elements(pedidos.json->'items') AS item(elem) ON TRUE

Luego, acceder a campos del item: item.elem->>'product_name', item.elem->>'price', etc.
Iterar un objeto JSONB:
FROM jsonb_each(clientes.data->'attributes') AS attr(key, value)

Luego puedes filtrar o sumar datos en value como necesites, e.g. WHERE attr.value->>'status' = 'active'.

Generación de resultados JSON (json_agg, row_to_json)
	•	Uso de json_agg vs row_to_json: Cuando necesites retornar datos en formato JSON, elige la función según el caso:
	•	Para obtener un objeto JSON de una sola fila (por ejemplo, detalles de un registro), usa row_to_json(t) sobre dicha fila o subconsulta t. Esto convierte una fila relacional en un objeto JSON con sus campos.
	•	Para obtener un arreglo JSON de múltiples filas (por ejemplo, una lista de resultados), utiliza json_agg(t) sobre un conjunto de filas/subconsulta t. Esto crea un array JSON donde cada elemento es el resultado JSON de cada fila.
	•	No combines ambas innecesariamente: No envuelvas un json_agg dentro de un row_to_json. Si ya estás agregando filas en un array JSON, no necesitas convertir ese array en JSON de nuevo (ya lo es). Por ejemplo, evita: row_to_json((SELECT json_agg(x) FROM (... ) x)). En su lugar, devuelve directamente json_agg(...) como tu resultado array.
	•	Ordenamiento dentro de agregación JSON: Si requieres un orden específico en el resultado de json_agg, realiza la ordenación en una subconsulta antes de la agregación. Por ejemplo: SELECT json_agg(row_to_json(t)) FROM (SELECT * FROM tabla ORDER BY campo) t;. No uses ORDER BY dentro de la llamada a json_agg en la misma consulta principal sin subselect, ya que puede causar errores a menos que esté en un contexto agregado apropiado.
	•	Subconsultas multi-fila a JSON: Si tienes una subconsulta que podría devolver varias filas y quieres incluir ese resultado como JSON en tu query principal (por ejemplo, una lista de elementos relacionados por cada registro), encapsula esa subconsulta con json_agg(row_to_json(...)). Esto te dará un array JSON de esas filas, en lugar de un único objeto o valor escalar. En resumen, utiliza json_agg para colecciones de objetos JSON, y row_to_json solo para estructuras individuales.

Con estas reglas específicas para JSONB, te aseguras de generar consultas SQL correctas y eficientes al interactuar con datos JSON en PostgreSQL, evitando errores comunes de sintaxis y lógica.