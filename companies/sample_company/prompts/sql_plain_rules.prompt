Reglas generales para generar SQL (Archivo 1)

Tipos de datos y casteo
	•	Casting según tipo declarado: Usa el tipo de cast correspondiente al tipo de dato definido en el esquema (ejemplo: utiliza ::INTEGER para campos enteros, ::NUMERIC para campos numéricos) en lugar de tipos genéricos.
	•	No mezclar tipos numéricos sin cast: Evita combinar valores INTEGER con NUMERIC (u otros tipos numéricos) sin un cast explícito. Si debes mezclarlos, castea todos al tipo de mayor precisión para mantener consistencia.
	•	Fechas en formato correcto: No conviertas columnas que ya son de tipo DATE o TIMESTAMP a texto ni uses funciones como TO_DATE sobre ellas. Úsalas directamente en comparaciones u ordenamientos (por ejemplo, no hagas TO_DATE(bc.init_date, 'DD-MM-YYYY'); simplemente usa bc.init_date). Si necesitas construir una fecha desde partes numéricas (ej. año y mes), genera un string con formato 'YYYY-MM-DD' y úsalo en TO_DATE(...) en lugar de concatenar literales de fecha.
	•	Booleans en expresiones: Las funciones agregadas (SUM, etc.) no aceptan valores booleanos directamente. Para contar o sumar basados en una condición booleana, transforma la condición a 0/1 con CASE WHEN ... THEN 1 ELSE 0 END antes de la agregación. De igual forma, no uses expresiones booleanas donde se espera numérico (por ejemplo, SUM(condición_booleana) es inválido; utiliza la construcción con CASE).

Funciones de agregación y cálculos
	•	Porcentajes y divisiones: Cuando calcules porcentajes, multiplica por 100.0 (con decimal) para forzar punto flotante y evita redondeos inesperados. Siempre protege las divisiones con NULLIF(denominador, 0) para prevenir errores de división por cero. Por ejemplo: ROUND(100.0 * SUM(valor) / NULLIF(SUM(total), 0), 0).
	•	Coherencia en expresiones numéricas: Asegúrate de que todos los componentes de una expresión numérica compartan el mismo tipo de dato. Aplica COALESCE con un literal del mismo tipo que el resultado esperado. Por ejemplo, si la suma es numérica usa COALESCE(SUM(...), 0::NUMERIC), si es entera COALESCE(..., 0::INTEGER). Esto evita mezclas implícitas de tipos.
	•	Aggregates condicionales (SUM, COUNT) sin FILTER: Para agregaciones condicionales, utiliza la sintaxis con CASE WHEN ... THEN ... END dentro de la función agregada en lugar de la cláusula FILTER (WHERE ...). Por ejemplo: SUM(CASE WHEN <condición> THEN <valor> ELSE 0 END) en lugar de SUM(<valor>) FILTER (WHERE <condición>). Del mismo modo, para contar bajo condición: COUNT(CASE WHEN <condición> THEN 1 END).

Agrupación (GROUP BY) y ordenamiento
	•	GROUP BY y columnas selectas: Si una consulta usa GROUP BY, todas las columnas del SELECT que no estén dentro de una función de agregación deben listarse explícitamente en la cláusula GROUP BY. Cualquier columna agregada a ORDER BY también debe estar en el SELECT (y en el GROUP BY si no es una agregación).
	•	Uso de alias en ORDER BY: PostgreSQL no permite referenciar directamente un alias de columna definido en el mismo nivel de SELECT dentro de ORDER BY cuando hay un GROUP BY activo. Para ordenar por una expresión agregada o calculada, repite la expresión original en el ORDER BY o encapsula la consulta en una subconsulta. Ejemplo incorrecto: ... SELECT to_char(fecha, 'MM-YYYY') AS mes ... GROUP BY mes ORDER BY TO_DATE('01-' || mes, 'DD-MM-YYYY') – en su lugar repite la expresión TO_DATE('01-' || to_char(fecha, 'MM-YYYY'), 'DD-MM-YYYY') en el ORDER BY, o haz el ORDER BY en un nivel externo.
	•	UNION/INTERSECT/EXCEPT y ORDER BY: Al combinar resultados con UNION, INTERSECT o EXCEPT, no uses expresiones o funciones en el ORDER BY final que no sean columnas seleccionadas. Solo puedes ordenar por columnas que aparezcan en el SELECT resultante (por nombre o posición), de lo contrario generará error.

Alias de tablas, subconsultas y CTEs
	•	Prefijo de alias obligatorio: Siempre que utilices más de una tabla o subconsulta en una consulta, antepone el alias de tabla a cada referencia de columna en SELECT, JOIN, ON, WHERE, GROUP BY y ORDER BY. Esto evita ambigüedad, especialmente si diferentes tablas tienen columnas con el mismo nombre (ejemplo: usar c.rut y b.rut en lugar de solo rut).
	•	Desambiguación de columnas duplicadas: Si dos tablas o CTEs tienen una columna con el mismo nombre, renómbralas o especifícalas con alias distintos en el resultado final para evitar ambigüedades. Por ejemplo, en un JOIN evita SELECT t1.id, t2.* cuando ambos tienen id – en su lugar selecciona campos específicos y usa alias (t1.id AS id_tabla1, etc.).
	•	Alias solo en su ámbito: No referencies un alias de tabla o subconsulta fuera del ámbito en que fue definido. Por ejemplo, dentro de una subconsulta (SELECT ... FROM tabla AS t) AS sub, solo puedes usar sub.columna en el query externo si columna fue seleccionada en la subconsulta. Nunca uses en el SELECT externo un alias interno que no esté definido como columna de salida. Asegúrate de que todas las columnas en la cláusula SELECT provengan de alias disponibles en ese mismo FROM/JOIN.
	•	CTE (Common Table Expressions): Cada CTE en una cláusula WITH debe separarse con coma (,) excepto el último antes del SELECT principal. Las columnas disponibles de un CTE son solo aquellas definidas explícitamente en su SELECT. No intentes acceder en la consulta principal (u otros CTEs) a columnas de la tabla base que el CTE no haya proyectado. Si necesitas un campo más adelante, inclúyelo en el SELECT del CTE.
	•	Reutilización de nombres y alias: Usa exactamente los nombres de columna definidos por un CTE o subconsulta cuando los referencies después. Evita crear alias muy similares que puedan confundir (ejemplo: no uses executable si en otro lugar usaste executive). Si necesitas un nombre distinto, utiliza AS para renombrar en el momento de la selección.
	•	No duplicar consultas con mismos CTE: No generes dos instrucciones SELECT seguidas reutilizando los mismos CTE previamente definidos. Si necesitas obtener múltiples resultados relacionados, combínalos en un solo SELECT (usando subconsultas, agregaciones, json_agg, etc.) o ejecuta consultas separadas. Un único conjunto de CTE debe concluir con un SELECT final que los consuma.
	•	Evitar SELECT * para cálculos posteriores: No uses SELECT * seguido de cálculos sobre esos campos en una consulta externa. En lugar de eso, selecciona explícitamente los campos requeridos y realiza los cálculos en el mismo SELECT o en la subconsulta. Esto hace la consulta más clara y evita errores al aplicar funciones sobre resultados ambiguos.
	•	Comentarios y sintaxis: Usa la sintaxis SQL correcta para alias y comentarios. Siempre asigna alias usando AS alias (o un espacio, e.g. col alias), nunca usando el formato alias = expresión (no válido en SQL). Para comentarios, utiliza -- comentario en línea o /* ... */ para bloques; no uses //, ya que no es un estilo de comentario válido en PostgreSQL.
	•	Uso correcto de LATERAL: Si utilizas JOIN LATERAL para subconsultas o funciones set-returning, ten cuidado con el alcance y filtrado: pon cualquier condición de filtrado de los resultados del lateral dentro de la subconsulta lateral (por ejemplo en su cláusula WHERE) o en la condición ON del LATERAL. No coloques un WHERE en la consulta externa inmediatamente después del LATERAL que afecte solo a filas producidas por este, ya que podrías convertir involuntariamente el LEFT JOIN LATERAL en un filtrado indeseado de la fila principal. Además, si el LATERAL proviene de una función JSON (como jsonb_array_elements que produce un alias con .value), utiliza alias.value->> para acceder a sus campos internos. Si en cambio la subconsulta LATERAL es una tabla normal, accede a sus columnas directamente por nombre (no mediante .value). Mantén los alias únicos por nivel para evitar confusión, especialmente con subconsultas LATERAL.

⸻
